"******************************************
" unite
"******************************************
"let g:unite_enable_start_insert=1
"let g:unite_source_history_yank_enable =1
"nmap <Space> [unite]
"nnoremap <silent> [unite]a :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
"nnoremap <silent> [unite]f :<C-u>Unite<Space>buffer file_mru<CR>
"nnoremap <silent> [unite]d :<C-u>Unite<Space>directory_mru<CR>
"nnoremap <silent> [unite]b :<C-u>Unite<Space>buffer<CR>
"nnoremap <silent> [unite]r :<C-u>Unite<Space>register<CR>
"nnoremap <silent> [unite]t :<C-u>Unite<Space>tab<CR>
"nnoremap <silent> [unite]h :<C-u>Unite<Space>history/yank<CR>
"nnoremap <silent> [unite]o :<C-u>Unite<Space>outline<CR>
"nnoremap <silent> [unite]<CR> :<C-u>Unite<Space>file_rec:!<CR>
"autocmd FileType unite call s:unite_my_settings()
"function! s:unite_my_settings()"{{{
"	nmap <buffer> <ESC> <Plug>(unite_exit)
"endfunction"}}}
"
"******************************************
" quickrun
"******************************************
"au FileType qf nnoremap <silent><buffer>q :quit<CR>
"nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
let g:quickrun_config = {}
"******************************************
" gitgutter
"******************************************
"let g:gitgutter_sign_added = '+'
"let g:gitgutter_sign_modified = '->'
"let g:gitgutter_sign_removed = 'x'
"
"******************************************
" lightline
"******************************************

let g:lightline = {
			\ 'colorscheme': 'powerline',
			\ 'mode_map': {'c': 'NORMAL'},
			\ 'active': {
			\   'left': [
			\	[ 'mode', 'paste' ],
			\	[ 'fugitive', 'gitgutter', 'filename']
			\	],
			\   'right': [
			\	['lineinfo', 'syntastic'],
			\	['percent'],
			\	['fileformat','fileencoding','filetype'],
			\	]
			\ },
			\ 'component_function': {
			\   'modified': 'MyModified',
			\   'readonly': 'MyReadonly',
			\   'fugitive': 'MyFugitive',
			\   'filename': 'MyFilename',
			\   'fileformat': 'MyFileformat',
			\   'filetype': 'MyFiletype',
			\   'fileencoding': 'MyFileencoding',
			\   'mode': 'MyMode',
			\   'syntastic': 'SyntasticStatuslineFlag',
			\   'gitgutter': 'MyGitGutter',
			\ },
			\ }

function! MyModified()
	return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
	return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
endfunction

function! MyFilename()
	return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
				\ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
				\  &ft == 'unite' ? unite#get_status_string() :
				\  &ft == 'vimshell' ? vimshell#get_status_string() :
				\ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
				\ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
	try
		if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
			return fugitive#head()
		endif
	catch
	endtry
	return ''
endfunction

function! MyFileformat()
	return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
	return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
	return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
	return winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! MyGitGutter()
	if ! exists('*GitGutterGetHunkSummary')
				\ || ! get(g:, 'gitgutter_enabled', 0)
				\ || winwidth('.') <= 90
		return ''
	endif
	let symbols = [
				\ g:gitgutter_sign_added . ' ',
				\ g:gitgutter_sign_modified . ' ',
				\ g:gitgutter_sign_removed . ' '
				\ ]
	let hunks = GitGutterGetHunkSummary()
	let ret = []
	for i in [0, 1, 2]
		if hunks[i] > 0
			call add(ret, symbols[i] . hunks[i])
		endif
	endfor
	return join(ret, ' ')
endfunction
""*********************************************
""neocomplete
""*********************************************
if neobundle#tap('neocomplete')
	call neobundle#config({
				\   'depends': ['Shougo/context_filetype.vim', 'ujihisa/neco-look', 'pocke/neco-gh-issues', 'Shougo/neco-syntax'],
				\ })

	" 起動時に有効化
	let g:neocomplete#enable_at_startup = 1
	" 大文字が入力されるまで大文字小文字の区別を無視する
	let g:neocomplete#enable_smart_case = 1
	" _(アンダースコア)区切りの補完を有効化
	let g:neocomplete#enable_underbar_completion = 1
	let g:neocomplete#enable_camel_case_completion  =  1
	" ポップアップメニューで表示される候補の数
	let g:neocomplete#max_list = 20
	" シンタックスをキャッシュするときの最小文字長
	let g:neocomplete#sources#syntax#min_keyword_length = 3
	" 補完を表示する最小文字数
	let	g:neocomplete#auto_completion_start_length = 2
	" preview window を閉じない
	let	g:neocomplete#enable_auto_close_preview = 0
	AutoCmd InsertLeave * silent! pclose!

	let g:neocomplete#max_keyword_width = 10000


	if !exists('g:neocomplete#delimiter_patterns')
		let	g:neocomplete#delimiter_patterns={}
	endif
	let	g:neocomplete#delimiter_patterns.ruby = ['::']

	if !exists('g:neocomplete#same_filetypes')
		let g:neocomplete#same_filetypes = {}
	endif
	let	g:neocomplete#same_filetypes.ruby = 'eruby'


	if !exists('g:neocomplete#force_omni_input_patterns')
		let	g:neocomplete#force_omni_input_patterns = {}
	endif

	let	g:neocomplete#force_omni_input_patterns.cpp = '[^.[:digit:] 	*\t]\%(\.\|->\)\w*\|\h\w*::\w*'
	let g:neocomplete#force_omni_input_patterns.typescript = '[^. \t]\.\%(\h\w*\)\?'  "	Same as	JavaScript
	let	g:neocomplete#force_omni_input_patterns.go = '[^. \t]\.\%(\h\w*\)\?' " Same	as JavaScript

	let	s:neco_dicts_dir=$HOME . '/dicts'
	if	isdirectory(s:neco_dicts_dir)
		let	g:neocomplete#sources#dictionary#dictionaries =	{
					\'ruby': s:neco_dicts_dir . '/ruby.dict',					
					\  'javascript':  s:neco_dicts_dir  .  '/jquery.dict',     
					\}
	endif
	let g:neocomplete#data_directory = $HOME . '/.vim/cache/neocomplete' 
	call neocomplete#custom#source('look', 'min_pattern_length', 1)
	call neobundle#untap()
endif

"""""""""""""""
" vim-marching  :Referenced(http://pocke.hatenablog.com/entry/2015/10/01/222216)
"""""""""""""""
if neobundle#tap('vim-marching')
	call neobundle#config({
				\   'autoload': {
				\     'filetypes': ['c', 'cpp']
				\   },
				\   'depends': ['Shougo/vimproc.vim', 'osyo-manga/vim-reunions']
				\ })

	let g:marching_enable_neocomplete = 1
	call neobundle#untap()
endif
""""""""""""
" neko-look
""""""""""""
if !exists('g:neocomplete#text_mode_filetypes')
	let g:neocomplete#text_mode_filetypes = {}
endif
let g:neocomplete#text_mode_filetypes = {
			\ 'rst': 1,
			\ 'markdown': 1,
			\ 'gitrebase': 1,
			\ 'gitcommit': 1,
			\ 'vcs-commit': 1,
			\ 'hybrid': 1,
			\ 'text': 1,
			\ 'help': 1,
			\ 'tex': 1,
			\ }
